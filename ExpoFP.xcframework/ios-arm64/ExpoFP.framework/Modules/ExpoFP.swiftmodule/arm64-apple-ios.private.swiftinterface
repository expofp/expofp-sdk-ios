// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name ExpoFP
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import Combine
import Foundation
import Swift
import SwiftUI
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import _WebKit_SwiftUI
public enum ExpoFpError : Swift.Error {
  case internalError(error: (any Swift.Error)? = nil, message: Swift.String? = nil)
  case decodingError(error: (any Swift.Error)? = nil, message: Swift.String? = nil)
  case downloadingPlanError(error: any Swift.Error)
  case locationProviderError(error: (any Swift.Error)? = nil, message: Swift.String? = nil)
  case invalidExpoKey
  case invalidPlanLink(ExpoFP.ExpoFpLinkType)
  case invalidZipFilePath(Swift.String)
  case planInfoRequestTimeout
  case javaScriptEvaluationError(any Swift.Error)
  case planLoadingError(message: Swift.String)
  case planNavigationError(any Swift.Error)
  case planDidTerminate
  case planMessageError(_: (any Swift.Error)? = nil)
}
public enum ExpoFpLinkType : Swift.Hashable, Swift.CustomStringConvertible {
  case expoKey(Swift.String)
  case downloadedPlanInfo(ExpoFP.ExpoFpDownloadedPlanInfo)
  public var description: Swift.String {
    get
  }
  public static func == (lhs: ExpoFP.ExpoFpLinkType, rhs: ExpoFP.ExpoFpLinkType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExpoFpPlanParameter : Swift.CustomStringConvertible, Swift.Hashable {
  case allowConsent(Swift.Bool)
  case debugMode(Swift.Bool)
  case disableBookmarked(Swift.Bool)
  case disableFeatured(Swift.Bool)
  case hideHeaderLogo(Swift.Bool)
  case hideLogoInBooth(Swift.Bool)
  case kioskMode(Swift.Bool)
  case monochrome(Swift.Bool)
  case noOverlay(Swift.Bool)
  case serviceWorker(Swift.Bool)
  case showYouAreHereMarker(Swift.String)
  case raw(name: Swift.String, value: Swift.String? = nil)
  case openAgenda
  case openLanguage
  case openKioskConfig
  case displayKiosk(Swift.Int)
  case viewBookmarksList
  case searchText(Swift.String)
  public var description: Swift.String {
    get
  }
  public var key: Swift.String {
    get
  }
  public var queryItem: Foundation.URLQueryItem {
    get
  }
  public static func == (a: ExpoFP.ExpoFpPlanParameter, b: ExpoFP.ExpoFpPlanParameter) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExpoFpPlanStatus {
  case error(ExpoFP.ExpoFpError)
  case initialization
  case loading(percentage: Swift.Int)
  case ready
  public var isError: Swift.Bool {
    get
  }
  public var isInitializing: Swift.Bool {
    get
  }
  public var isReady: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var percentageProgress: Swift.Int? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func isLoading(with progress: Swift.Int? = nil) -> Swift.Bool
  #endif
}
extension ExpoFP.ExpoFpPlanStatus : Swift.Equatable, Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public static func == (lhs: ExpoFP.ExpoFpPlanStatus, rhs: ExpoFP.ExpoFpPlanStatus) -> Swift.Bool
}
@_Concurrency.MainActor public enum ExpoFpPlan {
  @_Concurrency.MainActor public static let downloader: ExpoFP.ExpoFpPlanDownloader
  @_Concurrency.MainActor public static let preloader: ExpoFP.ExpoFpPlanPreloader
  @_Concurrency.MainActor public static let globalLocationProvider: ExpoFP.ExpoFpGlobalLocationProvider
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public static func createPlanPresenter(with planLink: ExpoFP.ExpoFpLinkType, additionalParams: [ExpoFP.ExpoFpPlanParameter] = [], locationProvider: (any ExpoFP.IExpoFpLocationProvider)? = nil, messageListener: (any ExpoFP.IExpoFpPlanMessageListener)? = nil, isDebugModeEnabled: Swift.Bool = false) -> any ExpoFP.IExpoFpPlanPresenter
  #endif
}
@_Concurrency.MainActor public protocol IExpoFpPlanMessageListener : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func bookmarkDidClick(_ bookmark: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpBookmark>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func boothDidClick(_ boothEvent: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpBoothClickEvent>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func categoryDidClick(_ category: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpCategory>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func currentFloorDidChange(_ floor: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpFloor>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func currentPositionDidChange(_ position: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpPosition>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func detailsDidClick(_ details: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpDetails?>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func directionDidBuild(_ direction: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpDirection?>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func exhibitorCustomButtonDidClick(_ buttonEvent: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpCustomButtonEvent>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func visitedDidClick(_ visitedEvent: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpVisitedClickEvent>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func windowErrorDidReceive(_ error: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpWindowError>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func consoleMessageDidReceive(_ message: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpConsoleMessage>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
}
extension ExpoFP.IExpoFpPlanMessageListener {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func windowErrorDidReceive(_ error: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpWindowError>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func consoleMessageDidReceive(_ message: ExpoFP.ExpoFpResult<ExpoFP.ExpoFpConsoleMessage>, from planLink: ExpoFP.ExpoFpLinkType)
  #endif
}
public typealias ExpoFpResult<T> = Swift.Result<T, ExpoFP.ExpoFpError>
public typealias ExpoFpPlanStatusPublisher = Combine.AnyPublisher<ExpoFP.ExpoFpPlanStatus, Swift.Never>
@_Concurrency.MainActor public protocol IExpoFpPlanPresenter : AnyObject, Swift.Identifiable {
  @_Concurrency.MainActor var id: Foundation.UUID { get }
  @_Concurrency.MainActor var additionalParams: [ExpoFP.ExpoFpPlanParameter] { get }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor var locationProvider: (any ExpoFP.IExpoFpLocationProvider)? { get }
  #endif
  @_Concurrency.MainActor var planLink: ExpoFP.ExpoFpLinkType { get }
  @_Concurrency.MainActor var isDebugModeEnabled: Swift.Bool { get }
  @_Concurrency.MainActor var planStatusPublisher: ExpoFP.ExpoFpPlanStatusPublisher { get }
  @_Concurrency.MainActor func getView() -> SwiftUICore.AnyView
  @_Concurrency.MainActor func getViewController() -> UIKit.UIViewController
  @_Concurrency.MainActor func applyAdditionalParams(_ additionalParams: [ExpoFP.ExpoFpPlanParameter], isSaved: Swift.Bool)
  @_Concurrency.MainActor func removeAdditionalParams(forKeys keys: [Swift.String])
  @_Concurrency.MainActor func setLocationProvider(_ locationProvider: any ExpoFP.IExpoFpLocationProvider)
  @_Concurrency.MainActor func removeLocationProvider()
  @_Concurrency.MainActor func setMessageListener(_ messageListener: any ExpoFP.IExpoFpPlanMessageListener)
  @_Concurrency.MainActor func removeMessageListener()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor func reloadPlan(planLink: ExpoFP.ExpoFpLinkType?, additionalParams: [ExpoFP.ExpoFpPlanParameter]?, locationProvider: (any ExpoFP.IExpoFpLocationProvider)?, messageListener: (any ExpoFP.IExpoFpPlanMessageListener)?, isDebugModeEnabled: Swift.Bool?)
  #endif
}
extension ExpoFP.IExpoFpPlanPresenter {
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func reloadPlan(planLink: ExpoFP.ExpoFpLinkType? = nil, additionalParams: [ExpoFP.ExpoFpPlanParameter]? = nil, locationProvider: (any ExpoFP.IExpoFpLocationProvider)? = nil, messageListener: (any ExpoFP.IExpoFpPlanMessageListener)? = nil, isDebugModeEnabled: Swift.Bool? = nil)
  #endif
  @_Concurrency.MainActor public func applyAdditionalParams(_ additionalParams: [ExpoFP.ExpoFpPlanParameter], isSaved: Swift.Bool = false)
  @_Concurrency.MainActor public func activateFloor(_ floor: ExpoFP.ExpoFpFloor)
  @_Concurrency.MainActor public func changeLanguage(_ language: ExpoFP.ExpoFpLanguage)
  @_Concurrency.MainActor public func findLocation()
  @_Concurrency.MainActor public func fitBounds()
  @_Concurrency.MainActor public func highlightBooths(externalIds: [Swift.String] = [])
  @_Concurrency.MainActor public func highlightExhibitors(externalIds: [Swift.String] = [])
  @_Concurrency.MainActor public func selectBooth(nameOrExternalId: Swift.String = "")
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func selectCategory(name: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func selectCurrentPosition(_ position: ExpoFP.ExpoFpPosition? = nil, focus: Swift.Bool = true)
  #endif
  @_Concurrency.MainActor public func selectExhibitor(nameOrExternalId: Swift.String = "")
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func selectRoute(from start: ExpoFP.ExpoFpRouteWaypoint?, to destination: ExpoFP.ExpoFpRouteWaypoint?)
  #endif
  @_Concurrency.MainActor public func selectRoute(waypoints: [ExpoFP.ExpoFpRouteWaypoint] = [])
  @_Concurrency.MainActor public func setBookmarks(_ bookmarks: [ExpoFP.ExpoFpBookmark])
  @_Concurrency.MainActor public func setElementsVisibility(_ elementsVisibility: ExpoFP.ExpoFpElementsVisibility)
  @_Concurrency.MainActor public func switchView()
  @_Concurrency.MainActor public func zoomIn()
  @_Concurrency.MainActor public func zoomOut()
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func boothsList() async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpBooth]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func boothsList(completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpBooth]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func categoriesList() async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpCategory]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func categoriesList(completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpCategory]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func exhibitorsList() async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpExhibitor]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func exhibitorsList(completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpExhibitor]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getElementsVisibility() async -> ExpoFP.ExpoFpResult<ExpoFP.ExpoFpElementsVisibility>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getElementsVisibility(completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<ExpoFP.ExpoFpElementsVisibility>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getFloors() async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpFloor]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getFloors(completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpFloor]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getOptimizedRoutes(waypoints: [ExpoFP.ExpoFpRouteWaypoint]) async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpRouteInfo]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getOptimizedRoutes(waypoints: [ExpoFP.ExpoFpRouteWaypoint], completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpRouteInfo]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func search(text: Swift.String) async -> ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpSearchModel]>
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func search(text: Swift.String, completion: @escaping @_Concurrency.MainActor (ExpoFP.ExpoFpResult<[ExpoFP.ExpoFpSearchModel]>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func evaluateCustomScript(_ script: Swift.String) async throws -> Any?
  #endif
}
public struct ExpoFpDownloadedPlanInfo : Swift.Codable, Swift.Comparable, Swift.CustomStringConvertible, Swift.Hashable, Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public let expoKey: Swift.String
  public let version: Swift.Int
  public var description: Swift.String {
    get
  }
  public static func < (lhs: ExpoFP.ExpoFpDownloadedPlanInfo, rhs: ExpoFP.ExpoFpDownloadedPlanInfo) -> Swift.Bool
  public static func == (a: ExpoFP.ExpoFpDownloadedPlanInfo, b: ExpoFP.ExpoFpDownloadedPlanInfo) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public typealias ExpoFpDownloadedPlanInfoResult = Swift.Result<ExpoFP.ExpoFpDownloadedPlanInfo, ExpoFP.ExpoFpError>
public struct ExpoFpPlanDownloader : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloadPlan(withExpoKey expoKey: Swift.String, completion: @escaping (ExpoFP.ExpoFpDownloadedPlanInfoResult) -> Swift.Void = {_ in})
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func downloadPlan(withExpoKey expoKey: Swift.String) async -> ExpoFP.ExpoFpDownloadedPlanInfoResult
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloadPlan(withZipFilePath filePath: Swift.String, completion: @escaping (ExpoFP.ExpoFpDownloadedPlanInfoResult) -> Swift.Void = {_ in})
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func downloadPlan(withZipFilePath filePath: Swift.String) async -> ExpoFP.ExpoFpDownloadedPlanInfoResult
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDownloadedPlansInfo(withExpoKey expoKey: Swift.String? = nil, completion: @escaping ([ExpoFP.ExpoFpDownloadedPlanInfo]) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDownloadedPlansInfo(withExpoKey expoKey: Swift.String? = nil) async -> [ExpoFP.ExpoFpDownloadedPlanInfo]
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func removeOldVersionsOfDownloadedPlans(withExpoKey expoKey: Swift.String? = nil) async
  #endif
  public func removeDownloadedPlan(with planInfo: ExpoFP.ExpoFpDownloadedPlanInfo) async
  public func removeAllDownloadedPlans() async
}
public enum ExpoFpFloorType : Swift.Codable, Swift.Hashable {
  case index(Swift.Int)
  case name(Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpFloorType, b: ExpoFP.ExpoFpFloorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExpoFpLocationProviderType : Swift.Hashable {
  case crowdConnected
  case indoorAtlas
  case unknown(name: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public static func == (a: ExpoFP.ExpoFpLocationProviderType, b: ExpoFP.ExpoFpLocationProviderType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpPosition : Swift.Codable, Swift.Hashable {
  public let x: Swift.Double?
  public let y: Swift.Double?
  public let z: ExpoFP.ExpoFpFloorType?
  public let angle: Swift.Double?
  public let lat: Swift.Double?
  public let lng: Swift.Double?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(x: Swift.Double? = nil, y: Swift.Double? = nil, z: ExpoFP.ExpoFpFloorType? = nil, angle: Swift.Double? = nil, lat: Swift.Double? = nil, lng: Swift.Double? = nil)
  #endif
  public static func == (a: ExpoFP.ExpoFpPosition, b: ExpoFP.ExpoFpPosition) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor final public class ExpoFpGlobalLocationProvider : @_Concurrency.MainActor ExpoFP.IExpoFpLocationProvider {
  @_Concurrency.MainActor final public let id: Foundation.UUID
  @_Concurrency.MainActor final public var isLocationUpdating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor final public var sharedProvider: (any ExpoFP.IExpoFpLocationProvider)?
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor final public var expoFpLocationProviderDelegate: (any ExpoFP.ExpoFpLocationProviderDelegate)? {
    get
    set
  }
  #endif
  @_Concurrency.MainActor final public func startUpdatingLocation()
  @_Concurrency.MainActor final public func stopUpdatingLocation()
  public typealias ID = Foundation.UUID
  @objc deinit
}
@_Concurrency.MainActor public protocol ExpoFpLocationProviderDelegate : AnyObject, Swift.Identifiable {
  @_Concurrency.MainActor func positionDidChange(_ newPosition: ExpoFP.ExpoFpPosition)
  @_Concurrency.MainActor func errorOccurred(_ error: ExpoFP.ExpoFpError, from provider: ExpoFP.ExpoFpLocationProviderType)
}
@_Concurrency.MainActor public protocol IExpoFpLocationProvider : AnyObject, Swift.Equatable, Swift.Identifiable {
  @_Concurrency.MainActor var isLocationUpdating: Swift.Bool { get }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor var expoFpLocationProviderDelegate: (any ExpoFP.ExpoFpLocationProviderDelegate)? { get set }
  #endif
  @_Concurrency.MainActor func startUpdatingLocation()
  @_Concurrency.MainActor func stopUpdatingLocation()
}
extension ExpoFP.IExpoFpLocationProvider {
  @_Concurrency.MainActor public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
@_Concurrency.MainActor public struct ExpoFpPlanPreloader {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func preloadPlan(with planLink: ExpoFP.ExpoFpLinkType, additionalParams: [ExpoFP.ExpoFpPlanParameter] = [], locationProvider: (any ExpoFP.IExpoFpLocationProvider)? = nil, messageListener: (any ExpoFP.IExpoFpPlanMessageListener)? = nil, isDebugModeEnabled: Swift.Bool = false) -> ExpoFP.ExpoFpPreloadedPlanInfo
  #endif
  @_Concurrency.MainActor public func getPreloadedPlansInfo() -> [ExpoFP.ExpoFpPreloadedPlanInfo]
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func getPreloadedPlanPresenter(with info: ExpoFP.ExpoFpPreloadedPlanInfo? = nil) -> (any ExpoFP.IExpoFpPlanPresenter)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @_Concurrency.MainActor public func disposePreloadedPlan(with info: ExpoFP.ExpoFpPreloadedPlanInfo? = nil) -> (any ExpoFP.IExpoFpPlanPresenter)?
  #endif
  @_Concurrency.MainActor public func removeAllPreloadedPlans()
}
@_hasMissingDesignatedInitializers final public class ExpoFpPreloadedPlanInfo : Swift.Hashable, Swift.CustomStringConvertible, Swift.Identifiable, Combine.ObservableObject {
  final public let id: Foundation.UUID
  @Combine.Published @_projectedValueProperty($planLink) final public var planLink: ExpoFP.ExpoFpLinkType {
    get
  }
  final public var $planLink: Combine.Published<ExpoFP.ExpoFpLinkType>.Publisher {
    get
  }
  final public var planStatusPublisher: ExpoFP.ExpoFpPlanStatusPublisher {
    get
  }
  final public var description: Swift.String {
    get
  }
  public static func == (lhs: ExpoFP.ExpoFpPreloadedPlanInfo, rhs: ExpoFP.ExpoFpPreloadedPlanInfo) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Foundation.UUID
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpBookmark : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public let name: Swift.String
  public let externalId: Swift.String
  public let bookmarked: Swift.Bool
  public init(name: Swift.String, externalId: Swift.String, bookmarked: Swift.Bool)
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpBookmark, b: ExpoFP.ExpoFpBookmark) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpBooth : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public let id: Swift.Int
  public let name: Swift.String
  public let layer: ExpoFP.ExpoFpLayer
  public let externalId: Swift.String
  public let isSpecial: Swift.Bool
  public let exhibitors: [Swift.Int]
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpBooth, b: ExpoFP.ExpoFpBooth) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpBoothClickEvent : Swift.Codable, Swift.Hashable {
  public let target: ExpoFP.ExpoFpBooth?
  public static func == (a: ExpoFP.ExpoFpBoothClickEvent, b: ExpoFP.ExpoFpBoothClickEvent) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpCategory : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public let id: Swift.Int
  public let name: Swift.String
  public let exhibitors: [Swift.Int]
  public static func == (a: ExpoFP.ExpoFpCategory, b: ExpoFP.ExpoFpCategory) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpConsoleMessage : Swift.Codable, Swift.CustomStringConvertible, Swift.Identifiable {
  public let id: Foundation.UUID
  public let time: Foundation.Date
  public let type: ExpoFP.ExpoFpConsoleMessage.OutputType
  public let message: Swift.String
  public var description: Swift.String {
    get
  }
  public enum OutputType : Swift.String, Swift.Codable, Swift.Equatable, Swift.CaseIterable {
    case assert
    case debug
    case error
    case info
    case log
    case trace
    case warn
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [ExpoFP.ExpoFpConsoleMessage.OutputType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [ExpoFP.ExpoFpConsoleMessage.OutputType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ExpoFpCustomButtonEvent : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public let externalId: Swift.String
  public let buttonNumber: Swift.Int
  public let buttonUrl: Foundation.URL
  public static func == (a: ExpoFP.ExpoFpCustomButtonEvent, b: ExpoFP.ExpoFpCustomButtonEvent) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpDetails : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public let id: Swift.Int
  public let type: ExpoFP.ExpoFpDetailsType
  public let name: Swift.String
  public let externalId: Swift.String
  public let boothsNames: [Swift.String]
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpDetails, b: ExpoFP.ExpoFpDetails) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExpoFpDetailsType : Swift.String, Swift.Codable, Swift.Hashable, Swift.CaseIterable {
  case booth
  case category
  case exhibitor
  case route
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [ExpoFP.ExpoFpDetailsType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ExpoFP.ExpoFpDetailsType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ExpoFpDirection : Swift.Codable, Swift.Hashable {
  public let distance: Swift.String
  public let duration: Foundation.TimeInterval
  public let from: ExpoFP.ExpoFpBooth?
  public let to: ExpoFP.ExpoFpBooth?
  public let lines: [ExpoFP.ExpoFpLine]
  public static func == (a: ExpoFP.ExpoFpDirection, b: ExpoFP.ExpoFpDirection) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpElementsVisibility : Swift.Codable, Swift.Hashable {
  public let controls: Swift.Bool
  public let levels: Swift.Bool
  public let header: Swift.Bool
  public let overlay: Swift.Bool
  public init(controls: Swift.Bool = true, levels: Swift.Bool = true, header: Swift.Bool = true, overlay: Swift.Bool = true)
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpElementsVisibility, b: ExpoFP.ExpoFpElementsVisibility) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpExhibitor : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public let id: Swift.Int
  public let name: Swift.String
  public let externalId: Swift.String
  public let booths: [Swift.Int]
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpExhibitor, b: ExpoFP.ExpoFpExhibitor) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpFloor : Swift.Codable, Swift.Hashable, Swift.Identifiable, Swift.CustomStringConvertible {
  public let name: Swift.String
  public let shortName: Swift.String
  public let description: Swift.String
  public let index: Swift.Int
  public let isActive: Swift.Bool
  public let isDisabled: Swift.Bool
  public var id: Swift.Int {
    get
  }
  public init(name: Swift.String, shortName: Swift.String = "", description: Swift.String = "", index: Swift.Int, isActive: Swift.Bool = false, isDisabled: Swift.Bool = false)
  public static func == (a: ExpoFP.ExpoFpFloor, b: ExpoFP.ExpoFpFloor) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum ExpoFpLanguage : Swift.String, Swift.Codable, Swift.Hashable, Swift.CustomStringConvertible, Swift.CaseIterable {
  case de
  case en
  case es
  case fr
  case it
  case ko
  case nl
  case pt
  case ru
  case tr
  case zh
  case sv
  case ar
  case th
  case vi
  case uk
  case he
  case kk
  case pl
  case mn
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [ExpoFP.ExpoFpLanguage]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ExpoFP.ExpoFpLanguage] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct ExpoFpLayer : Swift.Codable, Swift.Hashable {
  public let name: Swift.String
  public let description: Swift.String
  public static func == (a: ExpoFP.ExpoFpLayer, b: ExpoFP.ExpoFpLayer) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ExpoFP.ExpoFpLayer {
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpLine : Swift.Codable, Swift.Hashable {
  public let startPoint: ExpoFP.ExpoFpPoint
  public let endPoint: ExpoFP.ExpoFpPoint
  public let weight: Swift.Double?
  public static func == (a: ExpoFP.ExpoFpLine, b: ExpoFP.ExpoFpLine) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpPoint : Swift.Codable, Swift.Hashable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let layer: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(x: Swift.Double, y: Swift.Double, layer: Swift.String?)
  #endif
  public static func == (a: ExpoFP.ExpoFpPoint, b: ExpoFP.ExpoFpPoint) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpRouteInfo : Swift.Codable, Swift.Hashable {
  public let waypoints: [ExpoFP.ExpoFpRouteWaypoint]
  public static func == (a: ExpoFP.ExpoFpRouteInfo, b: ExpoFP.ExpoFpRouteInfo) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum ExpoFpRouteWaypoint : Swift.Codable, Swift.Hashable {
  case booth(Swift.String)
  case position(ExpoFP.ExpoFpPosition)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpRouteWaypoint, b: ExpoFP.ExpoFpRouteWaypoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpSchedule : Swift.Codable, Swift.Hashable, Swift.Identifiable, Swift.CustomStringConvertible {
  public let id: Swift.Int
  public let boothId: Swift.Int
  public let exhibitorId: Swift.Int?
  public let externalId: Swift.String
  public let name: Swift.String
  public let description: Swift.String
  public let startDate: Swift.String
  public let endDate: Swift.String
  public let link: Foundation.URL?
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpSchedule, b: ExpoFP.ExpoFpSchedule) -> Swift.Bool
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExpoFpSearchItemType : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  case booth(ExpoFP.ExpoFpBooth)
  case category(ExpoFP.ExpoFpCategory)
  case exhibitor(ExpoFP.ExpoFpExhibitor)
  case schedule(ExpoFP.ExpoFpSchedule)
  case unknown(ExpoFP.ExpoFpUnknownSearchItem)
  public enum RawType : Swift.String, Swift.Codable, Swift.Equatable, Swift.CaseIterable {
    case booth
    case category
    case exhibitor
    case schedule
    case unknown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.String)
    #endif
    public typealias AllCases = [ExpoFP.ExpoFpSearchItemType.RawType]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [ExpoFP.ExpoFpSearchItemType.RawType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public var id: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var externalId: Swift.String? {
    get
  }
  #endif
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpSearchItemType, b: ExpoFP.ExpoFpSearchItemType) -> Swift.Bool
  public typealias ID = Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpSearchModel : Swift.Codable, Swift.Comparable, Swift.Hashable, Swift.Identifiable {
  public let score: Swift.Double
  public let item: ExpoFP.ExpoFpSearchItemType
  public var id: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var externalId: Swift.String? {
    get
  }
  #endif
  public var rawType: ExpoFP.ExpoFpSearchItemType.RawType {
    get
  }
  public static func < (lhs: ExpoFP.ExpoFpSearchModel, rhs: ExpoFP.ExpoFpSearchModel) -> Swift.Bool
  public static func == (a: ExpoFP.ExpoFpSearchModel, b: ExpoFP.ExpoFpSearchModel) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExpoFpUnknownSearchItem : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public let id: Swift.String
  public let name: Swift.String
  public let externalId: Swift.String?
  public let entity: ExpoFP.ExpoFpUnknownSearchItem.Entity
  public init(from decoder: any Swift.Decoder) throws
  public struct Entity : Swift.Codable, Swift.Hashable {
    public let type: Swift.String
    public static func == (a: ExpoFP.ExpoFpUnknownSearchItem.Entity, b: ExpoFP.ExpoFpUnknownSearchItem.Entity) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func == (a: ExpoFP.ExpoFpUnknownSearchItem, b: ExpoFP.ExpoFpUnknownSearchItem) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpVisitedClickEvent : Swift.Codable, Swift.Hashable, Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public let name: Swift.String
  public let externalId: Swift.String
  public let visited: Swift.Bool
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: ExpoFP.ExpoFpVisitedClickEvent, b: ExpoFP.ExpoFpVisitedClickEvent) -> Swift.Bool
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ExpoFpWindowError : Swift.Codable {
  public let name: Swift.String
  public let column: Swift.Int
  public let line: Swift.Int
  public let stack: Swift.String
  public let errorName: Swift.String
  public let errorMessage: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ExpoFP.ExpoFpPlan : Swift.Sendable {}
extension ExpoFP.ExpoFpGlobalLocationProvider : Swift.Sendable {}
extension ExpoFP.ExpoFpPlanPreloader : Swift.Sendable {}
extension ExpoFP.ExpoFpConsoleMessage.OutputType : Swift.Hashable {}
extension ExpoFP.ExpoFpConsoleMessage.OutputType : Swift.RawRepresentable {}
extension ExpoFP.ExpoFpDetailsType : Swift.RawRepresentable {}
extension ExpoFP.ExpoFpLanguage : Swift.RawRepresentable {}
extension ExpoFP.ExpoFpSearchItemType.RawType : Swift.Hashable {}
extension ExpoFP.ExpoFpSearchItemType.RawType : Swift.RawRepresentable {}
